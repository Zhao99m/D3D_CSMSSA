import torch
import torch.nn as nn
import torch.nn.functional as F
from torchvision.models.video import r3d_50
from mmcv.ops import DeformConv3d

import torch
import torch.nn as nn
import torch.nn.functional as F

class MultiScaleSelfAttention4D(nn.Module):
    def __init__(self, in_channels, num_heads=8, sr_ratio=1, reduction_ratio=8):
        super(MultiScaleSelfAttention4D, self).__init__()
        self.in_channels = in_channels
        self.num_heads = num_heads
        self.sr_ratio = sr_ratio
        self.reduction_ratio = reduction_ratio

        # Query projection
        self.q = nn.Linear(in_channels, in_channels)

        # Key and value projections for multi-scale
        if sr_ratio > 1:
            self.sr1 = nn.Conv3d(in_channels, in_channels, kernel_size=sr_ratio, stride=sr_ratio)
            self.sr2 = nn.Conv3d(in_channels, in_channels, kernel_size=sr_ratio * 2, stride=sr_ratio * 2)
            self.norm1 = nn.LayerNorm(in_channels)
            self.norm2 = nn.LayerNorm(in_channels)
            self.kv1 = nn.Linear(in_channels, in_channels * 2)
            self.kv2 = nn.Linear(in_channels, in_channels * 2)
            self.local_conv1 = nn.Conv3d(in_channels // 2, in_channels // 2, kernel_size=3, padding=1, stride=1)
            self.local_conv2 = nn.Conv3d(in_channels // 2, in_channels // 2, kernel_size=3, padding=1, stride=1)
        else:
            self.kv = nn.Linear(in_channels, in_channels * 2)
            self.local_conv = nn.Conv3d(in_channels, in_channels, kernel_size=3, padding=1, stride=1)


        self.proj = nn.Linear(in_channels, in_channels)
        self.proj_drop = nn.Dropout(0.1)


        self.scale = (in_channels // num_heads) ** -0.5
        self.attn_drop = nn.Dropout(0.1)

    def forward(self, x, T, H, W):
        B, C, T, H, W = x.shape
        N = T * H * W  # Total number of spatial positions

        # Reshape input to (B, N, C)
        x = x.view(B, C, -1).transpose(1, 2)  # (B, N, C)

        # Query projection
        q = self.q(x).reshape(B, N, self.num_heads, C // self.num_heads).permute(0, 2, 1, 3)  # (B, num_heads, N, C // num_heads)

        if self.sr_ratio > 1:
            # Reshape input to (B, C, D, H, W)
            x_ = x.transpose(1, 2).reshape(B, C, D, H, W)

            # Multi-scale spatial reduction
            x_1 = self.sr1(x_).reshape(B, C, -1).transpose(1, 2)  # (B, N1, C)
            x_1 = self.act(self.norm1(x_1))
            x_2 = self.sr2(x_).reshape(B, C, -1).transpose(1, 2)  # (B, N2, C)
            x_2 = self.act(self.norm2(x_2))

            # Key and value projections
            kv1 = self.kv1(x_1).reshape(B, -1, 2, self.num_heads // 2, C // self.num_heads).permute(2, 0, 3, 1, 4)
            kv2 = self.kv2(x_2).reshape(B, -1, 2, self.num_heads // 2, C // self.num_heads).permute(2, 0, 3, 1, 4)
            k1, v1 = kv1[0], kv1[1]  # (B, num_heads // 2, N1, C // num_heads)
            k2, v2 = kv2[0], kv2[1]  # (B, num_heads // 2, N2, C // num_heads)

            # Attention for first scale
            attn1 = (q[:, :self.num_heads // 2] @ k1.transpose(-2, -1)) * self.scale  # (B, num_heads // 2, N, N1)
            attn1 = attn1.softmax(dim=-1)
            attn1 = self.attn_drop(attn1)
            v1 = v1 + self.local_conv1(v1.transpose(1, 2).reshape(B, -1, C // 2).transpose(1, 2).view(
                B, C // 2, D // self.sr_ratio, H // self.sr_ratio, W // self.sr_ratio).view(
                B, self.num_heads // 2, C // self.num_heads, -1).transpose(-1, -2)
            x1 = (attn1 @ v1).transpose(1, 2).reshape(B, N, C // 2)  # (B, N, C // 2)

            # Attention for second scale
            attn2 = (q[:, self.num_heads // 2:] @ k2.transpose(-2, -1)) * self.scale  # (B, num_heads // 2, N, N2)
            attn2 = attn2.softmax(dim=-1)
            attn2 = self.attn_drop(attn2)
            v2 = v2 + self.local_conv2(v2.transpose(1, 2).reshape(B, -1, C // 2).transpose(1, 2).view(
                B, C // 2, D * 2 // self.sr_ratio, H * 2 // self.sr_ratio, W * 2 // self.sr_ratio).view(
                B, self.num_heads // 2, C // self.num_heads, -1).transpose(-1, -2)
            x2 = (attn2 @ v2).transpose(1, 2).reshape(B, N, C // 2)  # (B, N, C // 2)

            # Concatenate results
            x = torch.cat([x1, x2], dim=-1)  # (B, N, C)
        else:
            # Single-scale attention
            kv = self.kv(x).reshape(B, -1, 2, self.num_heads, C // self.num_heads).permute(2, 0, 3, 1, 4)
            k, v = kv[0], kv[1]  # (B, num_heads, N, C // num_heads)

            # Attention
            attn = (q @ k.transpose(-2, -1)) * self.scale  # (B, num_heads, N, N)
            attn = attn.softmax(dim=-1)
            attn = self.attn_drop(attn)

            # Apply local convolution
            v = v + self.local_conv(v.transpose(1, 2).reshape(B, -1, C).transpose(1, 2).view(
                B, C, T, H, W).view(B, C, -1).transpose(1, 2)
            x = (attn @ v).transpose(1, 2).reshape(B, N, C)  # (B, N, C)

        # Output projection
        x = self.proj(x)
        x = self.proj_drop(x)

        # Reshape back to (B, C, T, H, W)
        x = x.transpose(1, 2).reshape(B, C, T, H, W)

        return x
